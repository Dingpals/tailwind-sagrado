


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import getClassInfo, {} from "../util/getClassInfo";
import CJSImportTransformer from "./CJSImportTransformer";
import ESMImportTransformer from "./ESMImportTransformer";
import FlowTransformer from "./FlowTransformer";
import JestHoistTransformer from "./JestHoistTransformer";
import JSXTransformer from "./JSXTransformer";
import NumericSeparatorTransformer from "./NumericSeparatorTransformer";
import OptionalCatchBindingTransformer from "./OptionalCatchBindingTransformer";
import OptionalChainingNullishTransformer from "./OptionalChainingNullishTransformer";
import ReactDisplayNameTransformer from "./ReactDisplayNameTransformer";
import ReactHotLoaderTransformer from "./ReactHotLoaderTransformer";

import TypeScriptTransformer from "./TypeScriptTransformer";








export default class RootTransformer {
   __init() {this.transformers = []}
  
  
   __init2() {this.generatedVariables = []}
  
  
  
  

  constructor(
    sucraseContext,
    transforms,
    enableLegacyBabel5ModuleInterop,
    options,
  ) {;RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);
    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    const {tokenProcessor, importProcessor} = sucraseContext;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options.disableESTransforms);

    if (!options.disableESTransforms) {
      this.transformers.push(
        new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager),
      );
      this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));
      this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));
    }

    if (transforms.includes("jsx")) {
      if (options.jsxRuntime !== "preserve") {
        this.transformers.push(
          new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options),
        );
      }
      this.transformers.push(
        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options),
      );
    }

    let reactHotLoaderTransformer = null;
    if (transforms.includes("react-hot-loader")) {
      if (!options.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }
      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    }

    // Note that we always want to enable the imports transformer, even when the import transform
    // itself isn't enabled, since we need to do type-only import pruning for both Flow and
    // TypeScript.
    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }
      this.transformers.push(
        new CJSImportTransformer(
          this,
          tokenProcessor,
          importProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          enableLegacyBabel5ModuleInterop,
          Boolean(options.enableLegacyTypeScriptModuleInterop),
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.preserveDynamicImport),
          Boolean(options.keepUnusedImports),
        ),
      );
    } else {
      this.transformers.push(
        new ESMImportTransformer(
          tokenProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.keepUnusedImports),
          options,
        ),
      );
    }

    if (transforms.includes("flow")) {
      this.transformers.push(
        new FlowTransformer(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("typescript")) {
      this.transformers.push(
        new TypeScriptTransformer(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("jest")) {
      this.transformers.push(
        new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor),
      );
    }
  }

  transform() {
    this.tokens.reset();
    this.processBalancedCode();
    const shouldAddUseStrict = this.isImportsTransformEnabled;
    // "use strict" always needs to be first, so override the normal transformer order.
    let prefix = shouldAddUseStrict ? '"use strict";' : "";
    for (const transformer of this.transformers) {
      prefix += transformer.getPrefixCode();
    }
    prefix += this.helperManager.emitHelpers();
    prefix += this.generatedVariables.map((v) => ` var ${v};`).join("");
    for (const transformer of this.transformers) {
      prefix += transformer.getHoistedCode();
    }
    let suffix = "";
    for (const transformer of this.transformers) {
      suffix += transformer.getSuffixCode();
    }
    const result = this.tokens.finish();
    let {code} = result;
    if (code.startsWith("#!")) {
      let newlineIndex = code.indexOf("\n");
      if (newlineIndex === -1) {
        newlineIndex = code.length;
        code += "\n";
      }
      return {
        code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    } else {
      return {
        code: prefix + code + suffix,
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    }
  }

  processBalancedCode() {
    let braceDepth = 0;
    let parenDepth = 0;
    while (!this.tokens.isAtEnd()) {
      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL)) {
        braceDepth++;
      } else if (this.tokens.matches1(tt.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      if (this.tokens.matches1(tt.parenL)) {
        parenDepth++;
      } else if (this.tokens.matches1(tt.parenR)) {
        if (parenDepth === 0) {
          return;
        }
        parenDepth--;
      }
      this.processToken();
    }
  }

  processToken() {
    if (this.tokens.matches1(tt._class)) {
      this.processClass();
      return;
    }
    for (const transformer of this.transformers) {
      const wasProcessed = transformer.process();
      if (wasProcessed) {
        return;
      }
    }
    this.tokens.copyToken();
  }

  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(tt._class, tt.name)) {
      throw new Error("Expected identifier for exported class name.");
    }
    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    this.processClass();
    return name;
  }

  processClass() {
    const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);

    // Both static and instance initializers need a class name to use to invoke the initializer, so
    // assign to one if necessary.
    const needsCommaExpression =
      (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) &&
      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;

    let className = classInfo.headerInfo.className;
    if (needsCommaExpression) {
      className = this.nameManager.claimFreeName("_class");
      this.generatedVariables.push(className);
      this.tokens.appendCode(` (${className} =`);
    }

    const classToken = this.tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) {
      throw new Error("Expected class to have a context erty>
        <Name>ReplicaPort</Name>
        <ReferencedMemberName>ReplicaServerPort</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>AuthType</Name>
        <ReferencedMemberName>AuthenticationType</ReferencedMemberName>
      </AliasProperty>
      <MemberSet>
        <Name>PsStandardMembers</Name>
        <Members>
          <NoteProperty>
            <Name>DefaultDisplayProperty</Name>
            <Value>VMName</Value>
          </NoteProperty>
          <PropertySet>
            <Name>DefaultDisplayPropertySet</Name>
            <ReferencedProperties>
              <Name>VMName</Name>
              <Name>ReplicationState</Name>
              <Name>ReplicationHealth</Name>
              <Name>ReplicationMode</Name>
              <Name>ReplicationFrequencySec</Name>
              <Name>ReplicationRelationshipType</Name>
              <Name>PrimaryServerName</Name>
              <Name>ReplicaServerName</Name>
              <Name>ReplicaServerPort</Name>
              <Name>AuthenticationType</Name>
            </ReferencedProperties>
          </PropertySet>
          <PropertySet>
            <Name>DefaultKeyPropertySet</Name>
            <ReferencedProperties>
              <Name>VMName</Name>
            </ReferencedProperties>
          </PropertySet>
        </Members>
      </MemberSet>
    </Members>
  </Type>
  <Type>
    <Name>Microsoft.HyperV.PowerShell.VMReplicationHealth</Name>
    <Members>
      <AliasProperty>
        <Name>Name</Name>
        <ReferencedMemberName>VMName</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Id</Name>
        <ReferencedMemberName>VMId</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>State</Name>
        <ReferencedMemberName>ReplicationState</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Health</Name>
        <ReferencedMemberName>ReplicationHealth</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>LReplTime</Name>
        <ReferencedMemberName>LastReplicationTime</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>PReplSize</Name>
        <ReferencedMemberName>PendingReplicationSize</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>AvgLatency</Name>
        <ReferencedMemberName>AverageReplicationLatency</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>AvgReplSize</Name>
        <ReferencedMemberName>AverageReplicationSize</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SuccReplCount</Name>
        <ReferencedMemberName>SuccessfulReplicationCount</ReferencedMemberName>
      </AliasProperty>
      <MemberSet>
        <Name>PsStandardMembers</Name>
        <Members>
          <NoteProperty>
            <Name>DefaultDisplayProperty</Name>
            <Value>VMName</Value>
          </NoteProperty>
          <PropertySet>
            <Name>DefaultDisplayPropertySet</Name>
            <ReferencedProperties>
              <Name>VMName</Name>
              <Name>ReplicationState</Name>
              <Name>ReplicationHealth</Name>
              <Name>LastReplicationTime</Name>
              <Name>PendingReplicationSize</Name>
              <Name>AverageReplicationLatency</Name>
              <Name>SuccessfulReplicationCount</Name>
              <Name>MissedReplicationCount</Name>
            </ReferencedProperties>
          </PropertySet>
          <PropertySet>
            <Name>DefaultKeyPropertySet</Name>
            <ReferencedProperties>
              <Name>VMName</Name>
            </ReferencedProperties>
          </PropertySet>
        </Members>
      </MemberSet>
    </Members>
  </Type>
  <Type>
    <Name>Microsoft.HyperV.PowerShell.VMMeteringReportForVirtualMachine</Name>
    <Members>
      <AliasProperty>
        <Name>AvgCPU</Name>
        <ReferencedMemberName>AverageProcessorUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>AvgRAM</Name>
        <ReferencedMemberName>AverageMemoryUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>MinRAM</Name>
        <ReferencedMemberName>MinimumMemoryUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>MaxRAM</Name>
        <ReferencedMemberName>MaximumMemoryUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>TotalDisk</Name>
        <ReferencedMemberName>TotalDiskAllocation</ReferencedMemberName>
      </AliasProperty>
    </Members>
  </Type>
  <Type>
    <Name>Microsoft.HyperV.PowerShell.VMMeteringReportForResourcePool</Name>
    <Members>
      <AliasProperty>
        <Name>AvgCPU</Name>
        <ReferencedMemberName>AverageProcessorUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>AvgRAM</Name>
        <ReferencedMemberName>AverageMemoryUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>MinRAM</Name>
        <ReferencedMemberName>MinimumMemoryUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>MaxRAM</Name>
        <ReferencedMemberName>MaximumMemoryUsage</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>TotalDisk</Name>
        <ReferencedMemberName>TotalDiskAllocation</ReferencedMemberName>
      </AliasProperty>
    </Members>
  </Type>
  <Type>
    <Name>Microsoft.HyperV.PowerShell.VMReplicationAuthorizationEntry</Name>
    <Members>
      <AliasProperty>
        <Name>AllowedPS</Name>
        <ReferencedMemberName>AllowedPrimaryServer</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>StorageLoc</Name>
        <ReferencedMemberName>ReplicaStorageLocation</ReferencedMemberName>
      </AliasProperty>
      <MemberSet>
        <Name>PsStandardMembers</Name>
        <Members>
          <NoteProperty>
            <Name>DefaultDisplayProperty</Name>
            <Value>AllowedPrimaryServer</Value>
          </NoteProperty>
        </Members>
      </MemberSet>
    </Members>
  </Type>
  <Type>
    <Name>Microsoft.HyperV.PowerShell.VMReplicationServer</Name>
    <Members>
      <AliasProperty>
        <Name>RepEnabled</Name>
        <ReferencedMemberName>ReplicationEnabled</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>AuthType</Name>
        <GetScriptBlock>
          if ($this.AllowedAuthenticationType -eq 1)
          {
          "Kerb"
          }
          elseif ($this.AllowedAuthenticationType -eq 2)
          {
          "Cert"
          }
          elseif ($this.AllowedAuthenticationType -eq 3)
          {
          "Kerb &amp; Cert"
          }
          else
          {
          " "
          }
        </GetScriptBlock>
      </ScriptProperty>
      <AliasProperty>
        <Name>KerbAuthPort</Name>
        <ReferencedMemberName>KerberosAuthenticationPort</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>CertAuthPort</Name>
        <ReferencedMemberName>CertificateAuthenticationPort</ReferencedMemberName>
   